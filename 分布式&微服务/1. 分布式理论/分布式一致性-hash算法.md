# 1. 分布式一致性算法的使用场景 #
主要用于**分布式数据存储**，比如：缓存、es、Hadoop、分布式数据库。

# 2. 常见的算法 #

## 2.1 hash取余算法 ##

原理：hash(key)%n (n为节点个数)  
缺点1：当增加节点时会造成缓存雪崩  
举例：原先有三个节点1 2 3，n为3，后新增节点4，其中3/4节点缓存会失效  
缺点2：未考虑各节点机器的性能

## 2.2 初级版一致性算法 ##
原理：计算出各节点的hash值，放在圆环上，圆环的长度为2^32(int的最大值)；计算数据key的值，同样映射到圆环上，  
顺时针方向，匹配最近的节点存储数据。  
优点：相比于取余算法，在新增节点时，只有极小部分节点会受到影响。失效数据比例低于1/n（n为新增前节点数）  
明显的缺点：计算节点的hash值，并不保证会均匀的分布在圆环上。很可能导致大量的数据最终都存储在某一台缓存  
服务器上。  
hash算法的选择：假如选择服务器节点ip计算hash值，以我的虚拟机为例： 192.168.1.11 192.168.1.12 192.168.1.13  
1、String的hashcode方法：  

    public class HashCodeTest {
	    public static void main(String[] args) {
		    System.out.println("192.168.0.1:11的哈希值:" + "192.168.1:11".hashCode());
		    System.out.println("192.168.0.1:12的哈希值:" + "192.168.1:12".hashCode());
		    System.out.println("192.168.0.1:13的哈希值:" + "192.168.1:13".hashCode());
		    System.out.println("int的最大值:" + Integer.MAX_VALUE);
	    }
    }

打印结果：  
192.168.0.1:11的哈希值:1734956744  
192.168.0.1:12的哈希值:1734956745  
192.168.0.1:13的哈希值:1734956746  
int的最大值:2147483647  

**绝大部分的数据都会存储到192.168.1.11这台机器上**，很明显，这种方法不合适。

2、其他计算方法

## 2.3 一致性hash算法 + 虚拟节点 ##
在一致性算法的基础上，每个节点计算多个hash值，可以通过增加编号等方式实现，其余不变。在存储和读取数据时，多了一步虚拟节点向真实节点转化的过程。虚拟节点越多，分布越均衡。但是过多会影响性能。建议值150~10000。

## 2.4 算法实现 ##
TODO 

# 3. 几个疑问 #


# 参考资料 #
https://www.cnblogs.com/lpfuture/p/5796398.html  
